#!/usr/bin/env bash

# Note: dcc-tools will be compilant with
# XDG Base Directory Specification in the future

# Current implementation will hardcode default paths

##
## Important paths
##
BIN_DIR="$HOME/.local/bin"
SRC_DIR="$HOME/.local/src"

TOOLS_DIR="${SRC_DIR}/dcc-tools"
BUCKETS_DIR="${TOOLS_DIR}/buckets"

# Set git command
git_cmd="git -C $TOOLS_DIR"

function myhelp_bucket() {

cat << EOF
Administra repositorios externos

  add <name> <git-url> Añade un repositorio externo
  remove <name>        Quita un repositorio externo
EOF

}

function myhelp_install() {

cat << EOF
Instala localmente un programa

  dcc-tools install <bucket>/<program>

Los programas se instalan dentro del directorio $TOOLS_DIR,
la ruta $HOME/.local/bin sólo contiene symlinks a ella.
EOF

}

function myhelp_remove() {

cat << EOF
Quita un programa instalado localmente

  dcc-tools remove <program>

No incluir el prefijo del bucket, se encontrará
automáticamente siguiendo la ruta del symlink.
EOF

}

function myhelp() {

    local tool="$1"

    if [[ -n $tool ]] ; then

        case "$tool" in
            bucket)
                myhelp_bucket
                exit
                ;;
            install)
                myhelp_install
                exit
                ;;
            remove)
                myhelp_remove
                exit
                ;;
            *)
                printf -- "No hay más información disponible.\n"
                exit
                ;;
        esac
    fi

cat << EOF
Administrador de paquetes locales para el servidor del dcc

  bucket      Administra repositorios externos **
  git         Ejecuta git dentro del repositorio principal
  help        Imprime esta ayuda
  install     Instala un programa **
  list        Lista los programas instalados
  os-release  Información sobre el servidor
  pull        Actualiza el repositorio principal
  remove      Quita un programa **
  update      Actualiza todos los repositorios

Vea 'dcc-tools help <command>' para leer acerca de subcomandos especificos,
actualmente sólo disponibles para los marcados con '**'.
EOF

}


###
### TOOLS
###

## dcc-tools list
##
function tools_list() {

    local arraySymlink
    readarray -t arraySymlink < <(find "$BIN_DIR" -type l)

    for i in "${arraySymlink[@]}"; do

        local symlink_target=$(readlink "$i")
        local target_basedir=$(dirname "$symlink_target")

        # This only handles native tools for DCC
        # e.g. imprimir, siitoweb

        if [[ "${target_basedir}" == "$TOOLS_DIR" ]] ; then
            printf -- "%s\n" "$(basename "$i")"
        fi

        # This only handles tools from buckets
        # $HOME/.local/src/dcc-tools/buckets/bucket_dir/program_dir
        # -- Already stripped --------------------------^^^^^^^^^^^
        # $HOME/.local/src/dcc-tools/buckets/bucket_dir
        target_basedir=$(dirname "$target_basedir")
        # $HOME/.local/src/dcc-tools/buckets

        if [[ "${target_basedir}" == "$BUCKETS_DIR" ]] ; then
            printf -- "%s\n" "$(basename "$i")"
        fi

    done

}

function update_tools() {

    printf -- '%s\n' "$TOOLS_DIR"
    $git_cmd pull
    for dir in $TOOLS_DIR/* ; do
        if [[ -d "$dir" ]] ; then
            printf -- '%s\n' "$dir"
            git -C "$dir" pull
        fi
    done

}

function install_tools() {

    local tool="$1"

    # Detect bucket
    if [[ "$tool" =~ "/" ]] ; then # found bucket
        bucket="${tool%%/*}"
        tool="${tool##*/}"
        program_path="${TOOLS_DIR}/${bucket}"

    else
        program_path="${TOOLS_DIR}"
    fi

    # Detect tool-fetch
    if [[ -f "${program_path}/${tool}-fetch" ]] ; then # found instructions
        tool_exec="${program_path}/${tool}-fetch"
        chmod +x "$tool_exec"
        $tool_exec install "${program_path}"
    fi
    chmod +x "${program_path}/${tool}"

    ln -sf "${program_path}/${tool}" "${BIN_DIR}/${tool}"
}

function self_remove_tools() {

    # delete symlinks
    printf -- 'Deleting symlinks...'
    for i in $(dcc-tools list) ; do
        rm "${BIN_DIR}/$i"
    done
    printf -- 'done\n'

    # delete source folder
    printf 'Deleting dcc-tools...'
    rm -rf "$TOOLS_DIR"
    printf -- 'done\n'

    # say goodbye
    printf -- 'Farewell good fellow\n'

}


function remove_tools() {

    local tool="$1"

    if [[ $tool == "dcc-tools" ]] ; then
        self_remove_tools
        exit
    fi

    symlink_bin=$(command -v "$tool")

    if [[ -z $symlink_bin ]] || [[ "$symlink_bin" =~ "/usr/" ]]  ; then
        printf -- 'ERROR: %s: not found\n' "$tool"
        exit
    fi

    fullpath_bin=$(readlink "${symlink_bin}")

    if [[ -f "${fullpath_bin}-fetch" ]] ; then
        rm ${fullpath_bin}
    fi

    rm "${BIN_DIR}/${tool}"

}

function edit_tools() {

    local mode=$1
    local tool=$2

    if [[ -z $tool ]] ; then
        printf -- "ERROR: no tool selected\n" 1>&2
        exit

    elif [[ ! -f "$TOOLS_DIR/$tool" ]] && [[ ! -f "$TOOLS_DIR/${tool}-fetch" ]] ; then
        printf -- 'ERROR: %s: unknown tool\n' "$tool" 1>&2
        exit
    fi

    if [[ $mode == "install" ]] ; then
        install_tools "${tool}"
    fi

}

function install_bucket() {

    local name="$1"
    local _url="$2"

    if [[ -z $name ]] ; then
        printf -- "ERROR: no bucket name given\n" 1>&2
        exit

    elif [[ -z $_url ]] ; then
        printf -- 'ERROR: %s: no given repository' "$name"
        exit
    fi

    $git_cmd submodule add --force "$_url" "$name"

}

function remove_bucket() {

    local name="${1:-val}"

    if [[ -d "$TOOLS_DIR/$name" ]] ; then
        $git_cmd submodule deinit -f "$TOOLS_DIR/$name"
        $git_cmd rm -f "$TOOLS_DIR/$name"

    else
        printf -- 'ERROR: %s: not found\n' "$name"
    fi

}

function bucket_function() {

for arg in "$@"
do
    case $arg in
        list)
            shift
            list_bucket
            exit
            ;;
        add)
            shift
            install_bucket "$@"
            exit
            ;;
        remove)
            shift
            remove_bucket "$1"
            exit
            ;;
        *)
            ;;
    esac
done

}

for arg in "$@"
do
    case $arg in
        help|-h|--help)
            shift
            myhelp "$1"
            exit
            ;;
        pull)
            shift
            $git_cmd fetch
            $git_cmd pull -q
            exit
            ;;
        git)
            shift
            $git_cmd "$@"
            exit
            ;;
        os-release)
            shift
            cat /etc/os-release
            exit
            ;;
        install)
            shift
            edit_tools "install" "$1"
            exit
            ;;
        remove)
            shift
            remove_tools "$1"
            exit
            ;;
        list)
            shift
            tools_list
            exit
            ;;
        bucket)
            shift
            bucket_function "$@"
            exit
            ;;
        update)
            shift
            update_tools
            exit
            ;;
        *)
            ;;
    esac
done
