#!/usr/bin/env bash

source "${CS_ROOT}/${CS_NAME}/lib/shared"

function deploy_symlinks() {

    local prog_name="$1"

    local arrayBinary=()
    readarray -t arrayBinary < <(find "${CS_ROOT}/${prog_name}/bin" -type f)

    printf -- '==> Making symlinks\n'

    for b in ${arrayBinary[@]} ; do
        b_name=$(basename $b)
        ln -sf "$b" "${CS_BIN_DIR}/${b_name}"
        printf -- '%s -> %s\n' "$b" "${CS_BIN_DIR}/${b_name}"
    done

}

function check_pkg_dir_not_empty() {

    readarray -t arrayPkgFiles < <(find "${CS_PACKAGES_DIR}" -type f -printf '%f\n')

    if [[ "${#arrayPkgFiles[@]}" -eq 0 ]] ; then
        printf -- 'No packages available\n'
        exit
    fi

}

function get_pkg_matches_with_target() {

    for pkg in "${arrayPkgFiles[@]}" ; do

         local pkg_info=( $(get_name_version_release "$pkg") )

         local pkg_name=${pkg_info[0]}
         local pkg_ver=${pkg_info[1]}
         local pkg_rel=${pkg_info[2]}

        if [[ "$pkg_name" == "$target_package" ]] ; then
            arrayTargetPkg+=("${pkg_name}-${pkg_ver}-${pkg_rel}")
        fi

    done

}

function answer_yes_or_exit() {

    read -r ans

    if [[ "$ans" != 'y' ]] ; then
        exit
    fi

}

function match_none() {

    printf -- 'Package not found for %s\n' "$target_package"
    exit

}

function match_single() {

    printf -- 'Package version is %s. Proceed? [y|n] ' "${arrayTargetPkg[0]##*-}"
    answer_yes_or_exit

}

function match_multiple() {

    printf -- '==> Multiple packages found\n'

    declare -i count
    count=0

    for pkg in "${arrayTargetPkg[@]}" ; do
        printf -- "[$count] %s\n" "$pkg"
        count+=1
    done

    unset number
    until [[ $number == +([0-9]) ]] ; do
        read -r -p 'Choose an index number: ' number
    done

    if [[ $number -gt $(($count-1)) ]] ; then
        printf -- 'error: index out of rage\n'
        exit

    else
        unpack_tarball "${arrayTargetPkg[$number]}"
    fi

}

function unpack_tarball() {

    local pkg_name_ver_rel="$1"

    pkg_info=( $(get_name_version_release "$pkg_name_ver_rel") )

    local pkg_name=${pkg_info[0]}
    local pkg_ver=${pkg_info[1]}
    local pkg_rel=${pkg_info[2]}

    if [[ -d "${CS_ROOT}/${pkg_name}" ]] ; then
        source "${CS_ROOT}/${pkg_name}/.PKGINFO"

        if [[ "$pkg_ver" != "$pkgver" ]] ; then

            printf -- 'Version %s installed. Replace with version %s? [y|n] ' "$pkgver" "$pkg_ver"
            answer_yes_or_exit
            printf -- '==> Updating %s\n' "$pkg_name"

        else

            printf -- 'Package already installed. Reinstall? [y|n] '
            answer_yes_or_exit
            printf -- '==> Reinstalling %s\n' "$pkg_name"
        fi

    else
        printf -- '==> Installing %s\n' "$pkg_name"
    fi

    printf -- '%s -> %s\n' "${pkg_name}-${pkg_ver}-${pkg_rel}.tar.xz"  "${CS_ROOT}/${pkg_name}"
    rm -rf "${CS_ROOT}/${pkg_name}"
    tar -xf "${CS_PACKAGES_DIR}/${pkg_name}-${pkg_ver}-${pkg_rel}.tar.xz" -C "${CS_ROOT}"

    deploy_symlinks ${pkg_name}

}
